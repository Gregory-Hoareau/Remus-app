{"ast":null,"code":"import { elfName } from './data/character/elf';\nimport { humanName } from './data/character/human';\nimport { dwarfNames } from './data/character/dwarf';\nimport { asianNames } from './data/character/asian';\nimport * as i0 from \"@angular/core\";\nexport let NameGeneratorService = /*#__PURE__*/(() => {\n  class NameGeneratorService {\n    constructor() {\n      this.final = '#';\n      this.learning = new LearningList();\n    }\n\n    setData(newData) {\n      this.data = newData;\n    }\n\n    generate(quantity, mini, maxi) {\n      if (this.previousData !== this.data) {\n        this.learning.learn(this.selectExampleList());\n        this.previousData = this.data;\n      }\n\n      const names = [];\n\n      while (names.length < quantity) {\n        const word = this.generateWord();\n\n        if (word.length <= maxi && word.length >= mini && !names.includes(word)) {\n          names.push(word);\n        }\n      }\n\n      return names;\n    }\n\n    generateWord() {\n      let word = '';\n      const markovPair = new MarkovPair();\n      let choice;\n\n      while (markovPair.last() !== this.final) {\n        choice = this.learning.pickOne(markovPair);\n        word += choice;\n        markovPair.updatePair(choice);\n      }\n\n      return word.slice(0, word.length - 1);\n    }\n\n    selectExampleList() {\n      switch (this.data) {\n        case 'asian':\n          return asianNames;\n\n        case 'dwarf':\n          return dwarfNames;\n\n        case 'human':\n          return humanName;\n\n        case 'elf':\n        default:\n          return elfName;\n      }\n    }\n\n  }\n\n  NameGeneratorService.ɵfac = function NameGeneratorService_Factory(t) {\n    return new (t || NameGeneratorService)();\n  };\n\n  NameGeneratorService.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n    token: NameGeneratorService,\n    factory: NameGeneratorService.ɵfac,\n    providedIn: 'root'\n  });\n  return NameGeneratorService;\n})();\n\nclass MarkovPair {\n  constructor() {\n    this.pair = ['', ''];\n  }\n\n  updatePair(lastLetter) {\n    this.pair.push(lastLetter);\n    this.pair = this.pair.slice(1);\n  }\n\n  clear() {\n    this.pair = ['', ''];\n  }\n\n  last() {\n    return this.pair[1];\n  }\n\n  toString() {\n    return this.pair.toString();\n  }\n\n}\n\nclass LearningList {\n  constructor() {\n    this.final = '#';\n    this.markovChain = {};\n  }\n  /**\r\n   * Construct the learning list from the given list\r\n   *\r\n   */\n\n\n  learn(exampleWordList) {\n    const lastPair = new MarkovPair();\n\n    for (const word of exampleWordList) {\n      for (const letter of word) {\n        this.addItem(lastPair, letter);\n        lastPair.updatePair(letter);\n      }\n\n      this.addItem(lastPair, this.final);\n      lastPair.clear();\n    }\n  }\n  /**\r\n   * Add as a possible following of 'parent' value, the 'child' value if not existing\r\n   * otherwise increase the apparition counter\r\n   *\r\n   */\n\n\n  addItem(parent, child) {\n    const parentStr = parent.toString();\n\n    if (this.markovChain[parentStr]) {\n      if (this.markovChain[parentStr][child]) {\n        this.markovChain[parentStr][child] += 1;\n      } else {\n        this.markovChain[parentStr][child] = 1;\n      }\n    } else {\n      this.markovChain[parentStr] = {};\n      this.markovChain[parentStr][child] = 1;\n    }\n  }\n  /**\r\n   * Select a successor of the parent value according to the learning list\r\n   * @param parent\r\n   */\n\n\n  pickOne(parent) {\n    let res = '';\n    const parentStr = parent.toString();\n\n    if (this.markovChain[parentStr]) {\n      let count = 0;\n      const following = this.markovChain[parentStr];\n\n      for (const key in following) {\n        count += following[key];\n      }\n\n      const rand = Math.ceil(Math.random() * count); // random value between 0 and count\n\n      let temp = 0;\n\n      for (const key in following) {\n        temp += following[key];\n\n        if (temp >= rand) {\n          return key;\n        }\n      }\n    }\n\n    return res;\n  }\n\n}","map":null,"metadata":{},"sourceType":"module"}