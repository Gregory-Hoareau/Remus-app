{"ast":null,"code":"import { __awaiter } from \"tslib\";\nimport { ModalController, Platform, ToastController } from '@ionic/angular';\nimport { Base64ToGallery } from '@ionic-native/base64-to-gallery/ngx';\nimport { ScreenOrientation } from '@ionic-native/screen-orientation/ngx';\nimport { AndroidPermissions } from '@ionic-native/android-permissions/ngx';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@ionic-native/android-permissions/ngx\";\nimport * as i2 from \"@ionic-native/screen-orientation/ngx\";\nimport * as i3 from \"@ionic/angular\";\nimport * as i4 from \"@ionic-native/base64-to-gallery/ngx\";\nimport * as i5 from \"@angular/common\";\nimport * as i6 from \"@angular/forms\";\nconst _c0 = [\"imageCanvas\"];\n\nfunction CanvasPage_div_9_ion_col_2_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r6 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"ion-col\", 19);\n    i0.ɵɵlistener(\"click\", function CanvasPage_div_9_ion_col_2_Template_ion_col_click_0_listener() {\n      const restoredCtx = i0.ɵɵrestoreView(_r6);\n      const color_r4 = restoredCtx.$implicit;\n      const ctx_r5 = i0.ɵɵnextContext(2);\n      return i0.ɵɵresetView(ctx_r5.selectColor(color_r4));\n    });\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const color_r4 = ctx.$implicit;\n    i0.ɵɵstyleProp(\"background\", color_r4);\n  }\n}\n\nfunction CanvasPage_div_9_ion_col_5_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"ion-col\", 20);\n    i0.ɵɵelement(1, \"ion-radio\", 21);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const color_r7 = ctx.$implicit;\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"value\", color_r7);\n  }\n}\n\nfunction CanvasPage_div_9_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r9 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"div\")(1, \"ion-row\");\n    i0.ɵɵtemplate(2, CanvasPage_div_9_ion_col_2_Template, 1, 2, \"ion-col\", 13);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(3, \"ion-radio-group\", 14);\n    i0.ɵɵlistener(\"ngModelChange\", function CanvasPage_div_9_Template_ion_radio_group_ngModelChange_3_listener($event) {\n      i0.ɵɵrestoreView(_r9);\n      const ctx_r8 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r8.selectedColor = $event);\n    });\n    i0.ɵɵelementStart(4, \"ion-row\");\n    i0.ɵɵtemplate(5, CanvasPage_div_9_ion_col_5_Template, 2, 1, \"ion-col\", 15);\n    i0.ɵɵelementEnd()();\n    i0.ɵɵelementStart(6, \"ion-range\", 16);\n    i0.ɵɵlistener(\"ngModelChange\", function CanvasPage_div_9_Template_ion_range_ngModelChange_6_listener($event) {\n      i0.ɵɵrestoreView(_r9);\n      const ctx_r10 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r10.lineWidth = $event);\n    });\n    i0.ɵɵelement(7, \"ion-icon\", 17)(8, \"ion-icon\", 18);\n    i0.ɵɵelementEnd()();\n  }\n\n  if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"ngForOf\", ctx_r0.colors);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngModel\", ctx_r0.selectedColor);\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"ngForOf\", ctx_r0.colors);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngModel\", ctx_r0.lineWidth);\n  }\n}\n\nexport let CanvasPage = /*#__PURE__*/(() => {\n  class CanvasPage {\n    constructor(androidPermissions, screenOrientation, plt, base64ToGallery, toastCtrl, modalCtrl) {\n      this.androidPermissions = androidPermissions;\n      this.screenOrientation = screenOrientation;\n      this.plt = plt;\n      this.base64ToGallery = base64ToGallery;\n      this.toastCtrl = toastCtrl;\n      this.modalCtrl = modalCtrl;\n      this.selectedColor = '#9e2956';\n      this.colors = ['#9e2956', '#c2281d', '#de722f', '#edbf4c', '#5db37e', '#459cde', '#4250ad', '#802fa3'];\n      this.drawing = false;\n      this.lineWidth = 5;\n      this.settings = true;\n      this.portrait = true;\n      this.permissions = false;\n    } // ask for permission when the modal is opened\n\n\n    ionViewWillEnter() {\n      this.checkPermissions();\n    } // right after init build the canvas inn which the picture will be edited\n    // canvas is build in function of the image choosed to be in background in order to keep the right dimension of the original image\n\n\n    ngAfterViewInit() {\n      const img = this.loadImage(this.image);\n      this.canvasElement = this.canvas.nativeElement;\n      this.canvasElement.width = this.plt.width() + '';\n      const height = this.plt.width() * img.height / img.width;\n      this.canvasElement.height = height + '';\n      this.setBackground(img);\n    } // verify if the application have the permissions to write in the gallery (if not, then ask for it)\n\n\n    checkPermissions() {\n      this.androidPermissions.checkPermission(this.androidPermissions.PERMISSION.WRITE_EXTERNAL_STORAGE).then(result => {\n        this.permissions = result.hasPermission;\n      }, err => {\n        this.androidPermissions.requestPermission(this.androidPermissions.PERMISSION.WRITE_EXTERNAL_STORAGE);\n      });\n\n      if (!this.permissions) {\n        this.androidPermissions.requestPermissions([this.androidPermissions.PERMISSION.WRITE_EXTERNAL_STORAGE]);\n      }\n    } // function to show (or hide) the settings for the canvas (color / size of the stroke)\n\n\n    displaySettings() {\n      if (this.settings) {\n        this.settings = false;\n      } else if (!this.settings) {\n        this.settings = true;\n      }\n    } // function to load an image from a string in base64 to a classical image format\n\n\n    loadImage(image) {\n      const img = new Image();\n      img.src = image;\n      return img;\n    } // function taking in acount an event trigerred on the html page listening for a first touch in the field of the canvas\n    // in order to save the position of the first touch in two variables\n\n\n    startDrawing(ev) {\n      this.drawing = true;\n      const canvasPosition = this.canvasElement.getBoundingClientRect();\n      this.saveX = ev.pageX - canvasPosition.x;\n      this.saveY = ev.pageY - canvasPosition.y;\n    } // function taking an event corresponding to the end of the draw (the finger releasing the screen)\n    // allow us to know when the draw should be finished (triggered in the html too)\n\n\n    endDrawing() {\n      this.drawing = false;\n    } // set the color of the pen to draw to the color choosen by the user\n\n\n    selectColor(color) {\n      this.selectedColor = color;\n    } // set an image in the backgroung of the canvas\n\n\n    setBackground(img) {\n      const ctx = this.canvasElement.getContext('2d');\n\n      img.onload = () => {\n        ctx.drawImage(img, 0, 0, this.canvasElement.width, this.canvasElement.height);\n      };\n    } // take an event in param allow us to follow the finger moving on the canvas by calculating the difference between\n    // the saved position and current position then draw on that pass\n\n\n    moved(ev) {\n      if (!this.drawing) {\n        return;\n      }\n\n      const canvasPosition = this.canvasElement.getBoundingClientRect();\n      const ctx = this.canvasElement.getContext('2d');\n      const currentX = ev.touches[0].pageX - canvasPosition.x;\n      const currentY = ev.touches[0].pageY - canvasPosition.y;\n      ctx.lineJoin = 'round';\n      ctx.strokeStyle = this.selectedColor;\n      ctx.lineWidth = this.lineWidth;\n      ctx.beginPath();\n      ctx.moveTo(this.saveX, this.saveY);\n      ctx.lineTo(currentX, currentY);\n      ctx.closePath();\n      ctx.stroke();\n      this.saveX = currentX;\n      this.saveY = currentY;\n    } // transform the content of the canvas to an url (string in base64) then export it to the gallery\n    // with base64ToGallery plugin\n\n\n    exportEditedImage() {\n      const dataUrl = this.canvasElement.toDataURL();\n      const options = {\n        prefix: 'edited_',\n        mediaScanner: false\n      };\n      this.testImage = dataUrl;\n      this.base64ToGallery.base64ToGallery(dataUrl, options).then(res => __awaiter(this, void 0, void 0, function* () {\n        const toast = yield this.toastCtrl.create({\n          message: 'Modification sauvegardée',\n          duration: 1000\n        });\n        toast.present();\n      }), err => console.log('Erreur ', err));\n      this.modalCtrl.dismiss(dataUrl, 'save');\n    }\n\n  }\n\n  CanvasPage.ɵfac = function CanvasPage_Factory(t) {\n    return new (t || CanvasPage)(i0.ɵɵdirectiveInject(i1.AndroidPermissions), i0.ɵɵdirectiveInject(i2.ScreenOrientation), i0.ɵɵdirectiveInject(i3.Platform), i0.ɵɵdirectiveInject(i4.Base64ToGallery), i0.ɵɵdirectiveInject(i3.ToastController), i0.ɵɵdirectiveInject(i3.ModalController));\n  };\n\n  CanvasPage.ɵcmp = /*@__PURE__*/i0.ɵɵdefineComponent({\n    type: CanvasPage,\n    selectors: [[\"app-canvas\"]],\n    viewQuery: function CanvasPage_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c0, 5);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.canvas = _t.first);\n      }\n    },\n    inputs: {\n      image: \"image\"\n    },\n    decls: 16,\n    vars: 2,\n    consts: [[\"color\", \"header\"], [2, \"font-family\", \"'Playfair display',serif\"], [\"slot\", \"end\", 3, \"click\"], [\"name\", \"cog-outline\", 1, \"ion-margin\"], [\"name\", \"close-outline\", 1, \"ion-margin\"], [3, \"forceOverscroll\"], [4, \"ngIf\"], [1, \"canvasContainer\"], [3, \"mousedown\", \"touchstart\", \"touchmove\", \"mousemove\", \"mouseup\", \"touchend\"], [\"imageCanvas\", \"\"], [\"vertical\", \"bottom\", \"horizontal\", \"end\", \"slot\", \"fixed\"], [\"color\", \"btn-purple\", 1, \"dice\", 3, \"click\"], [\"name\", \"download-outline\"], [\"class\", \"color-block\", \"tappable\", \"\", 3, \"background\", \"click\", 4, \"ngFor\", \"ngForOf\"], [3, \"ngModel\", \"ngModelChange\"], [\"class\", \"ion-text-center\", 4, \"ngFor\", \"ngForOf\"], [\"min\", \"2\", \"max\", \"20\", \"color\", \"primary\", 3, \"ngModel\", \"ngModelChange\"], [\"size\", \"small\", \"slot\", \"start\", \"name\", \"brush\"], [\"slot\", \"end\", \"name\", \"brush\"], [\"tappable\", \"\", 1, \"color-block\", 3, \"click\"], [1, \"ion-text-center\"], [3, \"value\"]],\n    template: function CanvasPage_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementStart(0, \"ion-header\")(1, \"ion-toolbar\", 0)(2, \"ion-title\", 1);\n        i0.ɵɵtext(3, \" Canvas Drawing \");\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(4, \"ion-buttons\", 2);\n        i0.ɵɵlistener(\"click\", function CanvasPage_Template_ion_buttons_click_4_listener() {\n          return ctx.displaySettings();\n        });\n        i0.ɵɵelement(5, \"ion-icon\", 3);\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(6, \"ion-buttons\", 2);\n        i0.ɵɵlistener(\"click\", function CanvasPage_Template_ion_buttons_click_6_listener() {\n          return ctx.modalCtrl.dismiss(ctx.image, \"cancel\");\n        });\n        i0.ɵɵelement(7, \"ion-icon\", 4);\n        i0.ɵɵelementEnd()()();\n        i0.ɵɵelementStart(8, \"ion-content\", 5);\n        i0.ɵɵtemplate(9, CanvasPage_div_9_Template, 9, 4, \"div\", 6);\n        i0.ɵɵelementStart(10, \"div\", 7)(11, \"canvas\", 8, 9);\n        i0.ɵɵlistener(\"mousedown\", function CanvasPage_Template_canvas_mousedown_11_listener($event) {\n          return ctx.startDrawing($event);\n        })(\"touchstart\", function CanvasPage_Template_canvas_touchstart_11_listener($event) {\n          return ctx.startDrawing($event);\n        })(\"touchmove\", function CanvasPage_Template_canvas_touchmove_11_listener($event) {\n          return ctx.moved($event);\n        })(\"mousemove\", function CanvasPage_Template_canvas_mousemove_11_listener($event) {\n          return ctx.moved($event);\n        })(\"mouseup\", function CanvasPage_Template_canvas_mouseup_11_listener() {\n          return ctx.endDrawing();\n        })(\"touchend\", function CanvasPage_Template_canvas_touchend_11_listener() {\n          return ctx.endDrawing();\n        });\n        i0.ɵɵelementEnd()();\n        i0.ɵɵelementStart(13, \"ion-fab\", 10)(14, \"ion-fab-button\", 11);\n        i0.ɵɵlistener(\"click\", function CanvasPage_Template_ion_fab_button_click_14_listener() {\n          return ctx.exportEditedImage();\n        });\n        i0.ɵɵelement(15, \"ion-icon\", 12);\n        i0.ɵɵelementEnd()()();\n      }\n\n      if (rf & 2) {\n        i0.ɵɵadvance(8);\n        i0.ɵɵproperty(\"forceOverscroll\", false);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.settings);\n      }\n    },\n    dependencies: [i5.NgForOf, i5.NgIf, i6.NgControlStatus, i6.NgModel, i3.IonButtons, i3.IonCol, i3.IonContent, i3.IonFab, i3.IonFabButton, i3.IonHeader, i3.IonIcon, i3.IonRadio, i3.IonRadioGroup, i3.IonRange, i3.IonRow, i3.IonTitle, i3.IonToolbar, i3.RadioValueAccessor, i3.SelectValueAccessor],\n    styles: [\"canvas[_ngcontent-%COMP%]{border:1px solid rgb(187,178,178);display:inline-block;align-self:center}.new-background-color[_ngcontent-%COMP%]{--background: #faefe1}.color-block[_ngcontent-%COMP%]{height:40px}.canvasContainer[_ngcontent-%COMP%]{text-align:center}\"]\n  });\n  return CanvasPage;\n})();","map":null,"metadata":{},"sourceType":"module"}